import{_ as e,c as a}from"./app.9c9fd7ca.js";var t="/img/in-post/2021-12-21/core-modules.png",r="/img/in-post/2021-12-21/reactivity-module.png",i="/img/in-post/2021-12-21/compiler-module.png",n="/img/in-post/2021-12-21/render-phase.png",o="/img/in-post/2021-12-21/mount-phase.png",h="/img/in-post/2021-12-21/patch-phase.png";const d={},s=a('<p>Reactivity Module, Compiler Module, Renderer Module</p><h2 id="three-core-modules" tabindex="-1"><a class="header-anchor" href="#three-core-modules" aria-hidden="true">#</a> Three core modules</h2><ul><li>Reactivity Module</li><li>Compiler Module</li><li>Renderer Module</li></ul><img src="'+t+'" alt="core-modules" style="zoom:33%;"><h3 id="reactivity-module" tabindex="-1"><a class="header-anchor" href="#reactivity-module" aria-hidden="true">#</a> Reactivity Module</h3><p>Reactivity module create JavaScript reactive objects that can be watched for changes.</p><p>When code which uses these objects are run they&#39;re tracked, so they can be run later if the reactive object changes.</p><img src="'+r+'" alt="reactivity-module" style="zoom:33%;"><h3 id="compiler-module" tabindex="-1"><a class="header-anchor" href="#compiler-module" aria-hidden="true">#</a> Compiler Module</h3><p>Compiler module takes HTML templates and compiles then into render functions.</p><img src="'+i+'" alt="compiler-module" style="zoom:33%;"><h3 id="renderer-module" tabindex="-1"><a class="header-anchor" href="#renderer-module" aria-hidden="true">#</a> Renderer Module</h3><p>Renderer module takes three phases</p><ul><li>Render Phase</li><li>Mount Phase</li><li>Patch Phase</li></ul><h4 id="render-phase" tabindex="-1"><a class="header-anchor" href="#render-phase" aria-hidden="true">#</a> Render Phase</h4><p>The render function is called and it returns a virtual DOM node.</p><img src="'+n+'" alt="render-phase" style="zoom:33%;"><h4 id="mount-phase" tabindex="-1"><a class="header-anchor" href="#mount-phase" aria-hidden="true">#</a> Mount Phase</h4><p>The render takes the virtual DOM node and makes DOM JavaScript calls to create a web page.</p><img src="'+o+'" alt="mount-phase" style="zoom:33%;"><h4 id="patch-phase" tabindex="-1"><a class="header-anchor" href="#patch-phase" aria-hidden="true">#</a> Patch Phase</h4><p>The render takes the old virtual node and the new virtual node, compares the two and updates only the parts of the web page that have changed using DOM JavaScript calls.</p><img src="'+h+'" alt="patch-phase" style="zoom:33%;"><h2 id="running-process" tabindex="-1"><a class="header-anchor" href="#running-process" aria-hidden="true">#</a> Running Process</h2><ul><li><p>First, the compiler changes the HTML into a render function.</p></li><li><p>Then the reactive objects are initialized using the reactivity module.</p></li><li><p>Next, the render module enter the render phase.</p></li><li><p>Render invokes the render function, whice references the reactive object.</p></li><li><p>Observer now watch this reactive object for changes, and the render function returns a vitural DOM node.</p></li><li><p>Next, in the mount phase, the mount function is called, using the virtual DOM node to create the web page.</p></li><li><p>Lastly, if any changes happen to our reactive object, whice is being watched, the render invokes the render function again, creating a new virtual DOM node.</p></li><li><p>Both the new and the old one Virtual DOM node, get sent into the patch function, which then makes updates to our webpage as needed.</p></li></ul>',25);function l(c,p){return s}var m=e(d,[["render",l],["__file","index.html.vue"]]);export{m as default};
